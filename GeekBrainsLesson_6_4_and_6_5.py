# 4. * (вместо 3) Решить задачу 3 для ситуации, когда объём данных в файлах превышает объём ОЗУ
# (разумеется, не нужно реально создавать такие большие файлы, это просто задел на будущее проекта).
# Также реализовать парсинг данных из файлов — получить отдельно фамилию, имя и отчество для пользователей
# и название каждого хобби: преобразовать в какой-нибудь контейнерный тип (список, кортеж, множество, словарь).
# Обосновать выбор типа. Подумать, какие могут возникнуть проблемы при парсинге. В словаре должны храниться данные,
# полученные в результате парсинга.

# ----------Решение-------------

# Преобразовать полученные данные в какой-либо контейнерный тип (список, кортеж, множество, словарь) когда объём
# данных в файлах превышает объём ОЗУ невозможно, поскольку это вызовит ошибку out of memory. Тут либо я не понял
# задание либо я не понял урок или тему. Я не знаю как это сделать.
# Можно только построчно илибо поблочно обрабатыватьи также поблочно сохранять в другой файл.
# Причем библиотки json и pikle так же использовать нельзя поскольку они требуют наличие готового контейнера который
# создать нельзя из-за ограничености оперативной памяти.

# Можно попробовать сформировать json в ручную зная его синтакис. Но тогда мы несможем с ним работать поскольку у нас
# нет оперативной памяти чтобы его прочитать с разу, и его все равно придется читать построчно.
#
# Либо записать полученные данные в .csv файл и тогда я не понимаю самого задания считать данные из одно файла и
# записать в другой, плюс с данным файлом сложно работать если необходимо будет получить определенное значение
# придется прочитывать весь файл.

# Я решил воспользоваться решением которое реализовал в задании 6_2 данные хранить в файлах в названии кторорых будут
# ключи. Так реализуется оперативный доступ к нужным данным.

# импортируем библиотеки os и sys
import sys
import os


# Реализуем функцию записи, либо перезаписи в файл hobby.txt, параметры link-путь к файлу, data- то что нужно записать.
# функция возвращает 1 если все прошло успешно.
def write_data(link, data):
    if not os.path.isdir(link):
        os.makedirs(link)
    fp = open(link + '/hobby.txt', "w", encoding='utf8')
    fp.write(str(data))
    fp.close()
    return 1


# Реализуем функцию чтения, из файла hobby.txt, параметр link это путь к файлу
# функция возвращает содержимое файла если все прошло успешно.
def read_data(link):
    if os.path.isdir(link):
        fp = open(link + '/hobby.txt', "r", encoding='utf8')
        data = fp.read().split(',')
        fp.close()
        return data


# Реализуем функцию make_dict с параметрами users_file, hobby_file, resutl_dir
def make_dict(users_file='users.csv', hobby_file='hobby.csv', resutl_dir='HOBBIES'):
    with open('users.csv', 'r', encoding='utf8') as f1, open('hobby.csv', 'r', encoding='utf8') as f2:
        # Открываем 2 файла сразу users.csv как f1 и hobby.csv как f2 с параметром read
        for line1 in f1:
            # проходим построчно первый файл с пользователями
            # в перменную fio заносим список из строки с заменой '\n' на пустой и разденной по символу ','
            fio = line1.replace('\n', '').split(',')
            # в перменную value заносим список из строки с заменой '\n' на пустой символ
            value = f2.readline().replace('\n', '')
            if value != '':
                # если value не пустая строка то в переменную hobbies заносим список из строки разденной по символу ','
                hobbies = value.split(',')
            else:
                # если value пустая строка то в переменную hobbies None
                hobbies = None

            # Вызываем функцию write_data, вней предаем параметрами директроию в которую будет записываться данные и
            # Имя Отчество и Фамилию разделенные / это позолит структурировать данные и не держать такой большой
            # файлов в одной директроии. Поскольку уникальных имен сильно меньше чем уникальных фамилий было принято
            # решение записывать данные таким образом
            write_data(f'{resutl_dir}/{fio[1]}/{fio[2]}/{fio[0]}', hobbies)

        if f2.readline() != '':
            # Проверяем если в файле hobby.csv остались еще строки, после того как мы прошли весь файл users.csv, то
            # возвращаем код 1
            return 1
    # возвращаем код 0
    return 0


# вызывам функцию с параметрами по умолчанию
# make_dict() # вызов закоментрован поскольку функция вызывается в задаи 6_5

# 5. ** (вместо 4) Решить задачу 4 и реализовать интерфейс командной строки, чтобы можно было задать путь к обоим
# исходным файлам и путь к выходному файлу со словарём. Проверить работу скрипта для случая, когда все файлы
# находятся в разных папках.

# ----------Решение-------------

# Используем метод sys.argv, необходимо указывать полный путь к файлам если
# онинаходятся в разных папках, если в команндной строке не будет параметров то функция вфзовется с параметром по
# умолчанию

if len(sys.argv) >= 4:
    if make_dict(sys.argv[1], sys.argv[2], sys.argv[3]) == 1:
        exit(1)
elif len(sys.argv) == 3:
    if make_dict(sys.argv[1], sys.argv[2]) == 1:
        exit(1)
elif len(sys.argv) == 2:
    if make_dict(sys.argv[1]) == 1:
        exit(1)
elif len(sys.argv) <= 2:
    if make_dict() == 1:
        exit(1)
