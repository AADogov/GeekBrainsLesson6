# 2. * (вместо 1) Найти IP адрес спамера и количество отправленных им запросов по данным файла логов из предыдущего
# задания. Примечания: спамер — это клиент, отправивший больше всех запросов; код должен работать даже с файлами,
# размер которых превышает объем ОЗУ компьютера.

# ----------Решение-------------

# Поскольку по условию у нас файл превышает  ОЗУ компьютера. мы неможем считать данные файла в список и провести его
# анализ. Для решения я вижу 2 варианта:
#   на каждой строчке прочитанного логфайла, необходимо провести сравнение IP со
# всеми уже прочианными строчками строчками до нее, причем мы не можем сохранить в их в список, их необходимо заново
# считывать сложность этого я не могу оценить но она будет больше чем O(n^2);
#   использовать базу данных;
#   реализовать аналог словаря только на  жестком диске где ключ это путь к файлу, а значение это содержимое
# файла только для того чтобы в одной директирии  не бвло 1000000 файлов я решил разбить на несколько
# директорий заменив точку в IP на /


import os


# Импорируем библиотеку для работы с файлами os

# Создаем функцию update_file котоарая будет реализовать обращение к файлу и запись в него, входными параметрами для
# функции будут путь к файлу и инкремент на который дует увеличено значение в файле.
def update_file(link, increment):
    if os.path.isdir(link):
        # если директория существует то открываем в ней файл requests.txt с параметром read
        fp = open(link + '/requests.txt', "r")
        # читаем значение перводим в int и записывае в переменную data
        data = int(fp.read())
        # закрываем файл
        fp.close()
    else:
        # если директтории не существует то создаем её, а переменную data приравневаем к нулю.
        # Это значит что, такого элемента в нашем импровезированном словаре нет
        os.makedirs(link)
        data = 0
    # открвыаем файл requests.txt в директроии link с параметром write, если его не было он создается автоматически
    fp = open(link + '/requests.txt', "w")
    # записываем либо перезаписываем в файл requests.txt' значение data + increment
    fp.write(str(data + increment))
    # зкрываем файл
    fp.close()
    # возвращаем это же значение data + increment кторое записали в файл
    return data + increment


# создаем 2 переменные spamer_ip - IP спамера и spamer_num-кодичество его запросов
spamer_ip = ''
spamer_num = 0
# Далее аналогично решению 6_1
with open("nginx_logs[1].txt", 'r') as f:
    for line in f:
        line_list = line.replace(' - - ', '++++').replace('"', '++++').replace(' ', '++++').split('++++')
        remote_addr = line_list[0]
        request_type = line_list[4]
        requested_resource = line_list[5]
        # в переменную mod_remote_addr что значит модифицированный remote_addr, заносим значение из remote_addr IP с
        # заменной разелительной точки и двоеточия в случае IPv6 на слеш/
        mod_remote_addr = remote_addr.replace('.', '/').replace(':', '/')
        # перменную number_of_reuest приравневаем значение функции update_file с параметрами:
        # link="IP/" + mod_remote_addr, я решил добавить директроию IP/ чтобы эта куча файлов
        # не огазалась непосредсвенно в директроии проекта
        # increment=1
        number_of_reuest = update_file("IP/" + mod_remote_addr, 1)
        # Далее сравниваем spamer_num и number_of_reuest
        if spamer_num < number_of_reuest:
            # если spamer_num < number_of_reuest то в spamer_num приравниваем number_of_reuest
            # и в  spamrer_ip приравниваем remote_addr
            spamer_num = number_of_reuest
            spamrer_ip = remote_addr

print(spamrer_ip, spamer_num)

# ответ 216.46.173.126 2350

# данное решение позволяет решить задачу за один проход файла и можно перативно запросить
# количество запросов обратившись к нужнорму файлу
# в архиве IP.rar приложена структура получившегося словаря
